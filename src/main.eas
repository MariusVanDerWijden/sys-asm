;; ███████╗ ██████╗  ██████╗ ██████╗   █████╗ ███████╗███╗   ███╗
;; ╚════██║██╔═████╗██╔═████╗╚════██╗ ██╔══██╗██╔════╝████╗ ████║
;;     ██╔╝██║██╔██║██║██╔██║ █████╔╝ ███████║███████╗██╔████╔██║
;;    ██╔╝ ████╔╝██║████╔╝██║██╔═══╝  ██╔══██║╚════██║██║╚██╔╝██║
;;    ██║  ╚██████╔╝╚██████╔╝███████╗ ██║  ██║███████║██║ ╚═╝ ██║
;;    ╚═╝   ╚═════╝  ╚═════╝ ╚══════╝ ╚═╝  ╚═╝╚══════╝╚═╝     ╚═╝
;;                                                              
;; This is an implementation of EIP-7002's pre-deploy contract. It implements
;; an unvalidated exit queue for beacon chain validators. The queue is tracked
;; using head and tail index pointers. After the queue is emptied, the pointers
;; are reset to zero.
;;
;; Entrance to the queue is determined only by a call's ability to pay the
;; exponentially increasing fee. This fee is computed using a simple function
;; which approximates true exponential value. No verification of ownership is 
;; done by the pre-deploy or the execution layer. Only once the exits are being
;; processed by the beacon chain is the validity verified. The fee is used to
;; avoid spamming of the exit queue.

;; -----------------------------------------------------------------------------
;; CONSTANTS -------------------------------------------------------------------
;; -----------------------------------------------------------------------------

#define SYSTEM_ADDR 0xfffffffffffffffffffffffffffffffffffffffe

#define EXCESS_EXITS 0
#define EXIT_COUNT 1

#define QUEUE_HEAD 2
#define QUEUE_TAIL 3
#define QUEUE_OFFSET 4

#define MIN_EXIT_FEE 1
#define TARGET_EXITS 2
#define MAX_EXITS 16
#define EXIT_FEE_UPDATE_FRACTION 17

#define RECORD_SIZE 68

;; -----------------------------------------------------------------------------
;; PROGRAM START ---------------------------------------------------------------
;; -----------------------------------------------------------------------------

.start:
  ;; Protect the system subroutine by checking if the caller is the system
  ;; address. 
  caller                ;; [caller]
  push20 SYSTEM_ADDR    ;; [sysaddr, caller]
  eq                    ;; [sysaddr == caller]
  push1 @read_exits     ;; [read_lbl, sysaddr == caller]
  jumpi                 ;; []

  ;; ---------------------------------------------------------------------------
  ;; USER SUBROUTINE -----------------------------------------------------------
  ;; ---------------------------------------------------------------------------
  ;;
  ;; Record new exit ~~
  ;; This is the default code path. It will attempt to record a user's exit
  ;; so long as they pay the required fee.
  ;; ;; ;; ;;

  ;; If calldatasize == 0, return the current excess exits.
  calldatasize          ;; [calldatasize]
  iszero                ;; [calldatasize == 0]
  iszero                ;; [calldatasize != 0]
  jumpi @check_input

  ;; Load excess exits and return the value.
  push EXCESS_EXITS     ;; [excess_exits_slot]
  sload                 ;; [excess_exits]
  push0                 ;; [0, excess_exits]
  mstore                ;; []
  push 32               ;; [32]
  push 0                ;; [0, 32]
  return                ;; []

check_input:
  ;; Verify the input is exactly 48 bytes, the size of a public key.
  calldatasize          ;; [calldatasize]
  push1 48              ;; [48, calldatasize]
  eq                    ;; [48 == calldatasize]
  iszero                ;; [48 != calldatasize]
  jumpi @revert         ;; []

  ;; Compute the fee using fake expo and the current excess exits.
  push EXIT_FEE_UPDATE_FRACTION
  push EXCESS_EXITS
  sload                 ;; [excess, update_fraction]
  push MIN_EXIT_FEE     ;; [min_exit_fee, excess, update_fraction]
  #include "fake_expo.eas"

  ;; Determine if the fee provided is enough to cover the exit fee.
  callvalue             ;; [callvalue, exit_fee]
  lt                    ;; [callvalue < exit_fee]
  jumpi @revert         ;; []

  ;; Exit can pay, increment exit count.
  push EXIT_COUNT
  sload                 ;; [exit_count]
  push1 1               ;; [1, exit_count]
  add                   ;; [exit_count+1]
  push EXIT_COUNT
  sstore                ;; []

  ;; Now insert exit into queue. First, compute the base storage slot
  push QUEUE_TAIL       ;; [tail_idx_slot]
  sload                 ;; [tail_idx]
  dup1                  ;; [tail_idx, tail_idx]
  push1 3               ;; [3, tail_idx, tail_idx]
  mul                   ;; [3*tail_idx, tail_idx]
  push QUEUE_OFFSET
  add                   ;; [slot, tail_idx]

  ;; Write address to queue.
  caller                ;; [caller, slot, ..]
  dup2                  ;; [slot, caller, slot, ..]
  sstore                ;; [slot, ..]

  push1 1               ;; [1, slot, ..]
  add                   ;; [slot, ..]

  ;; Store pk[0:32] to queue.
  push0                 ;; [0, slot, ..]
  calldataload          ;; [pubkey[0:32], slot, ..]
  dup2                  ;; [slot, pubkey[0:32], slot, ..]
  sstore                ;; [slot, ..]

  push1 1               ;; [1, slot, ..]
  add                   ;; [slot, ..]

  ;; Store pk[32:48] to queue.
  push1 32              ;; [32, slot, ..]
  calldataload          ;; [pubkey[32:48], slot, ..]
  swap1                 ;; [slot, pubkey[0:32], ..]
  sstore                ;; [..]

  ;; Increment queue tail over last and write to storage.
  push1 1               ;; [1, tail_idx]
  add                   ;; [tail_idx+1]
  push QUEUE_TAIL       ;; [tail_idx_slot]
  sstore                ;; []

  stop

;; -----------------------------------------------------------------------------
;; SYSTEM SUBROUTINE -----------------------------------------------------------
;; -----------------------------------------------------------------------------
;;
;; Pop exits from queue, update fee accumulator ~~
;; This is the logic executed by the protocol each block. It reads as many exits
;; as available from the queue, until the max exits per block is reached. The
;; exits are returned as a contiguous array of bytes with each record being
;; exactly 68 bytes.
;;
;;  Exit record:
;; 
;;  +------+--------+
;;  | addr | pubkey |
;;  +------+--------+
;;     20      48
;;
;; Because the exits are stored across three storage slots, there is some
;; shuffling to align the data.
;;
;; After reading the exits, they are removed from the queue by modifying
;; the queue's head index. The excess exits accumulator is updated so that
;; the new cost of exiting is reflected. Finally, the exit count is reset.
;; ;; ;; ;; ;;
read_exits:
  ;; Determine the size of the queue by calculating tail - head.
  push QUEUE_TAIL       ;; [tail_idx_slot, head_idx, head_idx]
  sload                 ;; [tail_idx]
  push QUEUE_HEAD       ;; [head_idx_slot, tail_idx]
  sload                 ;; [head_idx, tail_idx]

  ;; Now compute the count.
  dup1                  ;; [head_idx, head_idx, tail_idx]
  dup3                  ;; [tail_idx, head_idx, head_idx, tail_idx]
  sub                   ;; [count, head_idx, tail_idx]

  ;; Determine if count is greater than the max exits.
  dup1                  ;; [count, count, head_idx, tail_idx]
  push MAX_EXITS        ;; [exits_per_block, count, count, head_idx, tail_idx]
  gt                    ;; [exits_per_block > count, count, head_idx, tail_idx]
  jumpi @begin_loop     ;; [count, head_idx, tail_idx]

  ;; Discard count, use the max exits per block.
  pop                   ;; [head_idx, tail_idx]
  push MAX_EXITS        ;; [count, head_idx, tail_idx]

begin_loop:
  push0                 ;; [i, count, head_idx, tail_idx]

accum_loop:
  ;; This loop will read each exit and byte bang it into a 68 byte chunk.

  ;; Bounds check, ensure i < count.
  dup2                  ;; [count, i, count, head_idx, tail_idx]
  dup2                  ;; [i, count, i, count, head_idx, tail_idx]
  eq                    ;; [i == count, i, count, head_idx, tail_idx]
  jumpi @update_head    ;; [i, count, head_idx, tail_idx]

  ;; Precompute record_offset = i*RECORD_SIZE.
  dup1                  ;; [i, i, count, head_idx, tail_idx]
  push RECORD_SIZE      ;; [size, i, i, count, head_idx, tail_idx]
  mul                   ;; [record_offset, i, count, head_idx, tail_idx]

  ;; Determine the storage slot of the address for this iteration. This value is
  ;; also the base for the other two storage slots containing the public key.
  ;; The base slot will be (queue_offset + queue_head*3 + i*3).
  dup4                  ;; [head_idx, record_offset, i, ..]
  dup3                  ;; [i, head_idx, record_offset, i, ..]
  add                   ;; [i+head_idx, record_offset, i, ..]
  push 3                ;; [3, i+head_idx, record_offset, i, ..]
  mul                   ;; [3*(i+head_idx), record_offset, i, ..]
  push QUEUE_OFFSET     ;; [offset, 3*(i+head_idx), record_offset, i, ..]
  add                   ;; [addr_offset, record_offset, i, ..]

  ;; Read address. 
  dup1                  ;; [addr_offset, addr_offset, record_offset, i, ..]
  sload                 ;; [addr, addr_offset, record_offset, i, ..]

  ;; Compute pk[0:32] offset and read it.
  swap1                 ;; [addr_offset, addr, record_offset, i, ..]
  push 1                ;; [1, addr_offset, addr, record_offset, i, ..]
  add                   ;; [pk1_offset, addr, record_offset, i, ..]
  dup1                  ;; [pk1_offset, pk1_offset, addr, record_offset, i, ..]
  sload                 ;; [pk[0:32], pk1_offset, addr, record_offset, i, ..]

  ;; Compute pk[32:48] offset and read it.
  swap1                 ;; [pk1_offset, pk[0:32], addr, record_offset, i, ..]
  push 1                ;; [1, pk1_offset, pk[0:32], addr, record_offset, i, ..]
  add                   ;; [pk2_offset, pk[0:32], addr, record_offset, i, ..]
  sload                 ;; [pk[32:48], pk[0:32], addr, record_offset, i, ..]

  ;; Write values to memory flat and contiguously. This require combining the
  ;; three storage elements (addr, pk[0:32], pk[32:48]) so there is no padding.
  ;;  
  ;; Each stack element has the following layout:
  ;;
  ;; A: addr
  ;;  0x00 | 00 00 00 00 00 00 00 00 00 00 00 00 aa aa aa aa 
  ;;  0x10 | aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa
  ;; 
  ;; B: pk[0:32]
  ;;  0x00 | bb bb bb bb bb bb bb bb bb bb bb bb bb bb bb bb
  ;;  0x10 | bb bb bb bb bb bb bb bb bb bb bb bb bb bb bb bb
  ;;
  ;; C: pk[32:48]
  ;;  0x00 | cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc
  ;;  0x10 | 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  ;;
  ;; To get these three stack elements into the correct contiguous format, it is
  ;; neccessary to combine them in the follow form:
  ;;
  ;;  (A[12:32] ++ B[0:12], B[12:32] ++ C[0:12], C[12:16])

  ;; Shift addr bytes.
  swap2                 ;; [addr, pk[0:32], pk[32:48], record_offset, i, ..]
  push 12*8             ;; [96, addr, pk[0:32], pk[32:48], record_offset, i, ..]
  shl                   ;; [addr<<96, pk[0:32], pk[32:48], record_offset, i, ..]
  
  ;; Store addr at offset = i*RECORD_SIZE.
  dup4                  ;; [record_offset, addr<<96, pk[0:32], pk[32:48], record_offset, i, ..]
  mstore                ;; [pk[0:32], pk[32:48], record_offset, i, ..]

  ;; Store pk[0:32] at offset = i*RECORD_SIZE + 20.
  dup3                  ;; [record_offset, pk[0:32], pk[32:48], record_offset, i, ..]
  push 20               ;; [20, record_offset, pk[0:32], pk[32:48], record_offset, i, ..]
  add                   ;; [record_offset+20, pk[0:32], pk[32:48], record_offset, i, ..]
  mstore                ;; [pk[32:48], record_offset, i, ..]

  ;; Store pk[32:48] at offset = i*RECORD_SIZE + 52.
  swap1                 ;; [record_offset, pk[32:48], i, ..]
  push 52               ;; [52, record_offset, pk[32:48], i, ..]
  add                   ;; [record_offset+52, pk[32:48], i, ..]
  mstore                ;; [i, ..]

  ;; Increment i.
  push 1                ;; [1, i, ..]
  add                   ;; [i+1, ..]

  jump @accum_loop      ;; [i, count, head_idx, tail_idx]

update_head:
  ;; All exits have been read, update queue by adding the count read to the
  ;; current head index.
  swap2                 ;; [head_idx, count, count, tail_idx]
  add                   ;; [new_head_idx, count, tail_idx]

  ;; If the new head is equal to the tail, reset the queue by zeroing them both.
  dup1                  ;; [new_head_idx, new_head_idx, count, tail_idx]
  swap3                 ;; [tail_idx, new_head_idx, count, new_head_idx]
  eq                    ;; [new_head_idx == tail_idx, count, new_head_idx]
  jumpi @reset_queue    ;; [count, new_head_idx]

  ;; Otherwise, write the new head to storage.
  swap1                 ;; [new_head_idx, count]
  push QUEUE_HEAD       ;; [head_idx_slot, new_head_idx, count]
  sstore                ;; [count]

  jump @update_excess   ;; [count]

reset_queue:
  ;; Since the queue is empty, both the head and tail indexes can be zeroed.
  swap1                 ;; [new_head_idx, count]
  pop                   ;; [count]

  push0                 ;; [0, count]
  push QUEUE_HEAD       ;; [head_slot, 0, count]
  sstore                ;; [count]

  push0                 ;; [0, count]
  push QUEUE_TAIL       ;; [tail_slot, 0, count]
  sstore                ;; [count]

update_excess:
  ;; Update the new excess exits.
  push EXCESS_EXITS     ;; [excess_exits_slot, count]
  sload                 ;; [excess, count]
  push EXIT_COUNT       ;; [exit_count_slot, excess, count]
  sload                 ;; [count, excess, count]

  ;; If the sum of the previous excess exits and exits added in the current
  ;; block is greater than the target, subtract the target from the sum and set
  ;; it as the new excess exits value.
  push TARGET_EXITS     ;; [target, count, excess, count]
  dup3                  ;; [excess, target, count, excess]
  dup3                  ;; [count, excess, target, count, excess, count]
  add                   ;; [count+excess, target, count, excess, count]
  gt                    ;; [count+excess > target, count, excess, count]
  jumpi @compute_excess ;; [count, excess, count]
  
  ;; Zero out excess.
  pop                   ;; [excess, count]
  pop                   ;; [count]
  push0                 
  jump @store_excess

compute_excess:
  add                   ;; [count+excess, count]
  push TARGET_EXITS
  swap1                 ;; [count+excess, target, count]
  sub                   ;; [new_excess, count]

store_excess:
  push EXCESS_EXITS     ;; [excess_slot, new_excess, count]
  sstore                ;; [count]

  ;; Reset exit count.
  push0                 ;; [0, count]
  push EXIT_COUNT       ;; [exit_count_slot, 0, count]
  sstore                ;; [count]

  ;; Return the exits.
  push RECORD_SIZE      ;; [record_size, count]
  mul                   ;; [size]
  push0                 ;; [0, size]
  return                ;; []

;; Revert subroutine.
revert:
  push0
  push0
  revert
